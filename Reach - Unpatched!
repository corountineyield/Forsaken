repeat task.wait() until game:IsLoaded();

local Players = game:GetService('Players');
local RunService = game:GetService('RunService');
local Rep = game:GetService("ReplicatedStorage")
local Player = Players.LocalPlayer;
repeat task.wait() until Player.Character
local Character = Player.Character
local Humanoid = Character:WaitForChild("Humanoid");
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart");

Player.CharacterAdded:Connect(function(NewCharacter)
    Character = NewCharacter;
    Humanoid = Character:WaitForChild("Humanoid");
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart");
end);

local WallCheck = getgenv().WallCheck or true;
local FaceCheck = getgenv().FaceCheck or true;
local TeamCheck = getgenv().TeamCheck or true;
local FaceCheckValue = getgenv().FaceCheckValue or 14;

local function DoWallCheck(From, To)
    local Params = RaycastParams.new()
    Params.FilterType = Enum.RaycastFilterType.Blacklist
    Params.FilterDescendantsInstances = {Character}
    
    local Raycast = workspace:Raycast(From, (To - From).Unit * (To - From).Magnitude, Params)
    if Raycast then
        local Hit = Raycast.Instance
        if Hit and Hit.Parent and (Hit.Parent:FindFirstChild("Humanoid") or Hit.Parent.Parent:FindFirstChild("Humanoid")) then
            return false
        end
        return true
    end
    return false
end

local function IsFacing(Target)
    local LookDirection = HumanoidRootPart.CFrame.LookVector
    local DirectionToTarget = (Target.HumanoidRootPart.Position - HumanoidRootPart.Position).Unit
    local DotProduct = LookDirection:Dot(DirectionToTarget)
    return DotProduct > FaceCheckValue
end

local function IsPlayerInKillers(TargetPlayer)
    local PlayersFolder = workspace.Players
    
    if PlayersFolder:FindFirstChild("Killers") then
        for _, PlayerObj in pairs(PlayersFolder.Killers:GetChildren()) do
            if PlayerObj:GetAttribute("Username") == TargetPlayer then
                return true
            end
        end
    end
    
    return false
end

local function GetAbilityName(V)
    if typeof(V) == "buffer" then
        return buffer.tostring(V)
    end
    return V
end

local function CleanName(Name)
    return tostring(Name):gsub("\"", "")
end

local RNG = Random.new();
local IsKiller = false;
local IsSurvivor = false;
local IsAttacking = false;
local AttackStart = 0;

task.spawn(function()
    while true do
        local PlayersFolder = workspace.Players
        local PlayerName = Player.Name
        
        IsKiller = false
        IsSurvivor = false
        
        if PlayersFolder:FindFirstChild("Killers") then
            for _, PlayerObj in pairs(PlayersFolder.Killers:GetChildren()) do
                if PlayerObj:GetAttribute("Username") == PlayerName then
                    IsKiller = true
                    break
                end
            end
        end
        
        if PlayersFolder:FindFirstChild("Survivors") then
            for _, PlayerObj in pairs(PlayersFolder.Survivors:GetChildren()) do
                if PlayerObj:GetAttribute("Username") == PlayerName then
                    IsSurvivor = true
                    break
                end
            end
        end
        
        task.wait(1)
    end
end)

local Remote = Rep:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")

Remote.OnClientEvent:Connect(function(Action, Data)
    if Action ~= "UseActorAbility" then return end
    if typeof(Data) ~= "table" or not Data[1] then return end

    local AbilityName = CleanName(GetAbilityName(Data[1]))

    if (AbilityName == "Carving Slash" or
        AbilityName == "Slash" or
        AbilityName == "Stab" or
        AbilityName == "Punch" or
        AbilityName == "Dagger" or
        AbilityName == "Block") then
        IsAttacking = true
        AttackStart = tick()
    end
end)

RunService.Heartbeat:Connect(function()
    if IsAttacking and (tick() - AttackStart > 1.5) then
        IsAttacking = false
    end

    if not IsKiller and not IsSurvivor then
        return
    end
    
    if not HumanoidRootPart then
        return
    end

    if not IsAttacking then
        return
    end

    local Target;
    local NearestDist = IsSurvivor and 15 or (getgenv().Range or 14);

    local function Loop(T)
        for _,V in T do
            if V == Character or not V:FindFirstChild("HumanoidRootPart") then
                continue;
            end

            local Dist = (V.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude;

            if Dist < NearestDist then
                local PassedWallCheck = not WallCheck or not DoWallCheck(HumanoidRootPart.Position, V.HumanoidRootPart.Position)
                local PassedFaceCheck = not FaceCheck or IsFacing(V)
                local PassedTeamCheck = true
                
                if TeamCheck then
                    local TargetPlayer = Players:GetPlayerFromCharacter(V)
                    if TargetPlayer then
                        if IsKiller then
                            PassedTeamCheck = not IsPlayerInKillers(TargetPlayer.Name)
                        elseif IsSurvivor then
                            PassedTeamCheck = IsPlayerInKillers(TargetPlayer.Name)
                        end
                    end
                end
                
                if PassedWallCheck and PassedFaceCheck and PassedTeamCheck then
                    NearestDist = Dist;
                    Target = V;
                end
            end
        end
    end

    local PlayersFolder = workspace.Players
    if PlayersFolder:FindFirstChild("Killers") then
        Loop(PlayersFolder.Killers:GetChildren())
    end
    if PlayersFolder:FindFirstChild("Survivors") then
        Loop(PlayersFolder.Survivors:GetChildren())
    end
    
    local NPCFolder = workspace.Map:FindFirstChild("NPCs", true)
    if NPCFolder then
        Loop(NPCFolder:GetChildren())
    end

    if not Target then
        return
    end

    local OldVelocity = HumanoidRootPart.Velocity;
    local NeededVelocity =
    (Target.HumanoidRootPart.Position + Vector3.new(
        RNG:NextNumber(-1.5, 1.5),
        0,
        RNG:NextNumber(-1.5, 1.5)
    ) + (Target.HumanoidRootPart.Velocity * (Player:GetNetworkPing() * 1.25))
        - HumanoidRootPart.Position
    ) / (Player:GetNetworkPing() * 2);

    HumanoidRootPart.Velocity = NeededVelocity;
    RunService.RenderStepped:Wait();
    HumanoidRootPart.Velocity = OldVelocity;
end)
